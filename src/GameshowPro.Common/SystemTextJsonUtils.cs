using GameshowPro.Common.JsonConverters;

namespace GameshowPro.Common;

public class Persistence : IPersistence
{
    internal Persistence() { }
    public async Task<T?> Depersist<T>(string? path, bool rethrowDeserializationExceptions, bool renameFailedFiles, ILogger? logger, CancellationToken? cancellationToken) where T : new()
        => await SystemTextJsonUtils.Depersist<T>(path, rethrowDeserializationExceptions, renameFailedFiles, null, logger, cancellationToken);

    public Task Persist<T>(T obj, string? path, ILogger? logger, CancellationToken? cancellationToken)
        => SystemTextJsonUtils.Persist(obj, path, null, logger, cancellationToken);
}

public static class SystemTextJsonUtils
{
    /// <summary>
    /// The default <see cref="JsonSerializerOptions"/> used for serialization and deserialization. This can also be used as the basis of custom options.
    /// </summary>
    public static JsonSerializerOptions DefaultJsonSerializerOptions { get; } = new()
    {
        PropertyNameCaseInsensitive = true,
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
        DefaultIgnoreCondition = JsonIgnoreCondition.Never,
        WriteIndented = true,
        TypeInfoResolver = new OptInResolver<DataMemberAttribute>()
    };

    static SystemTextJsonUtils()
    {
        DefaultJsonSerializerOptions.Converters.Add(new JsonConverters.TypeConverter());
        DefaultJsonSerializerOptions.Converters.Add(new JsonStringEnumConverter());
        DefaultJsonSerializerOptions.Converters.Add(new IpAddressConverter());
    }

    /// <summary>
    /// Deserialize a JSON file to an object of type T. If unsuccessful, return null.
    /// </summary>
    /// <typeparam name="T">The type of object to deserialize</typeparam>
    /// <param name="path">The path to the JSON file to be deserialized</param>
    /// <param name="logger">An optional logger to receive log messages generated by the deserialization process</param>
    /// <param name="rethrowDeserializationExceptions">If true, exceptions encountered during the deserialization process will be rethrown</param>
    /// <param name="renameFailedFiles">If true and the specified file cannot be successfully deserialized, it will be renamed to allow later recreation</param>
    public static async Task<T?> Depersist<T>(string? path, bool rethrowDeserializationExceptions, bool renameFailedFiles, JsonSerializerOptions? jsonSerializerOptions, ILogger? logger, CancellationToken? cancellationToken)
    {
        T? obj = default;
        if (path is not null && File.Exists(path))
        {
            bool renameBroken = false;
            using FileStream fileStream = File.OpenRead(path);
            try
            {
                obj = await Depersist<T>(fileStream, jsonSerializerOptions, cancellationToken);
                logger?.LogInformation("Successfully deserialized from {path}", path);
            }
            catch (Exception ex)
            {
                logger?.LogError(ex, "Exception while deserializing {path}", path);
                if (renameFailedFiles)
                {
                    renameBroken = true;
                }
                if (rethrowDeserializationExceptions)
                {
                    throw new JsonException($"Exception while deserializing {path}", ex);
                }
            }

            if (renameBroken)
            {
                RenameBrokenFile(path, logger);
            }
        }
        return obj;
    }

    /// <summary>
    /// Deserialize a JSON text stream to an object of type T. If unsuccessful, throws exception. Never returns null.
    /// </summary>
    /// <typeparam name="T">The type of object to deserialize</typeparam>
    /// <param name="stream">The path to the JSON file to be deserialized</param>
    /// <param name="jsonSerializerOptions">Custom <see cref="JsonSerializerOptions"/>. If not supplied <see cref="DefaultJsonSerializerOptions"/> is used.</param>
    /// <param name="logger">An optional logger to receive log messages generated by the deserialization process</param>
    /// <exception cref="JsonException">Thrown if deserialization fails or returns null</exception>
    public static async Task<T> Depersist<T>(Stream stream, JsonSerializerOptions? jsonSerializerOptions, ILogger? logger, CancellationToken? cancellationToken)
    {
        T? obj;
        try
        {
            obj = await Depersist<T>(stream, jsonSerializerOptions, cancellationToken);
            logger?.LogInformation("Successfully deserialized from stream");
        }
        catch (Exception ex)
        {
            logger?.LogError(ex, "Exception while deserializing stream");
            throw new JsonException($"Exception while deserializing stream", ex);
        }
        if (obj is null)
        {
            logger?.LogWarning("Deserialization from stream returned null");
            throw new JsonException("Deserialization from stream returned null");
        }
        return obj;
    }

    private static async Task<T?> Depersist<T>(Stream stream, JsonSerializerOptions? jsonSerializerOptions, CancellationToken? cancellationToken)
        => await JsonSerializer.DeserializeAsync<T>(stream, jsonSerializerOptions ?? DefaultJsonSerializerOptions, cancellationToken ?? default);

    /// <summary>
    /// Deserialize a JSON file to an object of type T. If unsuccessful, create a new object using the supplied factory.
    /// </summary>
    /// <typeparam name="T">The type of object to deserialize</typeparam>
    /// <param name="path">The path to the JSON file to be deserialized</param>
    /// <param name="logger">An optional logger to receive log messages generated by the deserialization process</param>
    /// <param name="factory"></param>A factory method to create a new object if deserialization fails</param>
    /// <param name="rethrowDeserializationExceptions">If true, exceptions encountered during the deserialization process will be rethrown</param>
    /// <param name="renameFailedFiles">If true and the specified file cannot be successfully deserialized, it will be renamed to allow later recreation</param>
    public static async Task<T> Depersist<T>(string? path, Func<T> factory, bool rethrowDeserializationExceptions, bool renameFailedFiles, JsonSerializerOptions? jsonSerializerOptions, ILogger? logger, CancellationToken? cancellationToken)
    {
        T? obj = await Depersist<T>(path, rethrowDeserializationExceptions, renameFailedFiles, jsonSerializerOptions, logger, cancellationToken);
        if (obj == null)
        {
            obj = factory();
            logger?.LogInformation("Created new object because nothing could be deserialized from {path}", path);
        }
        return obj;
    }

    /// <summary>
    /// Persist any type to a JSON file.
    /// </summary>
    /// <typeparam name="T">The type of object to be persisted.</typeparam>
    /// <param name="path">Path to the JSON file.</param>
    /// <param name="obj">Object to be persisted.</param>
    public static async Task Persist<T>(T obj, string? path, JsonSerializerOptions? jsonSerializerOptions, ILogger? logger, CancellationToken? cancellationToken)
    {
        if (obj is null || path is null)
        {
            return;
        }
        if (!EnsureDirectory(path))
        {
            logger?.LogError("Failed to find or create directory for {path}", path);
            return;
        }
        await using FileStream fileStream = File.Create(path);
        await Persist<T>(obj, fileStream, jsonSerializerOptions, cancellationToken);
    }

    /// <summary>
    /// Persist any type to a JSON text stream.
    /// </summary>
    /// <typeparam name="T">The type of object to be persisted.</typeparam>
    /// <param name="stream">Stream to receive the JSON text.</param>
    /// <param name="obj">Object to be persisted.</param>
    public static async Task Persist<T>(T obj, Stream stream, JsonSerializerOptions? jsonSerializerOptions, CancellationToken? cancellationToken)
        => await JsonSerializer.SerializeAsync(stream, obj, jsonSerializerOptions ?? DefaultJsonSerializerOptions, cancellationToken ?? default);

    public static Persistence Persistence { get; } = new();
}
