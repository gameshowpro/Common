using GameshowPro.Common.JsonConverters;

namespace GameshowPro.Common;

public class Persistence : IPersistence
{
    internal Persistence() { }
    public async Task<T?> Depersist<T>(string? path, bool rethrowDeserializationExceptions, bool renameFailedFiles, ILogger? logger, CancellationToken? cancellationToken) where T : new()
        => await SystemTextJsonUtils.Depersist<T>(path, rethrowDeserializationExceptions, renameFailedFiles, logger, cancellationToken);

    public Task Persist<T>(T obj, string? path, ILogger? logger, CancellationToken? cancellationToken)
        => SystemTextJsonUtils.Persist(obj, path, logger, cancellationToken);
}

public static class SystemTextJsonUtils
{
    private static readonly JsonSerializerOptions s_jsonSerializerOptions = new()
    {
        PropertyNameCaseInsensitive = true,
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
        DefaultIgnoreCondition = JsonIgnoreCondition.Never,
        WriteIndented = true,
        TypeInfoResolver = new OptInResolver()
    };

    static SystemTextJsonUtils()
    {
        s_jsonSerializerOptions.Converters.Add(new JsonConverters.TypeConverter());
        s_jsonSerializerOptions.Converters.Add(new JsonStringEnumConverter());
        s_jsonSerializerOptions.Converters.Add(new IpAddressConverter());
    }

    /// <summary>
    /// Deserialize a JSON file to an object of type T. If unsuccessful, return null.
    /// </summary>
    /// <typeparam name="T">The type of object to deserialize</typeparam>
    /// <param name="path">The path to the JSON file to be deserialized</param>
    /// <param name="logger">An optional logger to receive log messages generated by the deserialization process</param>
    /// <param name="rethrowDeserializationExceptions">If true, exceptions encountered during the deserialization process will be rethrown</param>
    /// <param name="renameFailedFiles">If true and the specified file cannot be successfully deserialized, it will be renamed to allow later recreation</param>
    public static async Task<T?> Depersist<T>(string? path, bool rethrowDeserializationExceptions, bool renameFailedFiles, ILogger? logger, CancellationToken? cancellationToken)
    {
        T? obj = default;
        if (path is not null && File.Exists(path))
        {
            bool renameBroken = false;
            using FileStream fileStream = File.OpenRead(path);
            try
            {
               obj = await JsonSerializer.DeserializeAsync<T>(fileStream, s_jsonSerializerOptions, cancellationToken ?? default);
                logger?.LogInformation("Successfully deserialized from {path}", path);
            }
            catch (Exception ex)
            {
                logger?.LogError(ex, "Exception while deserializing {path}", path);
                if (renameFailedFiles)
                {
                    renameBroken = true;
                }
                if (rethrowDeserializationExceptions)
                {
                    throw new JsonException($"Exception while deserializing {path}", ex);
                }
            }

            if (renameBroken)
            {
                RenameBrokenFile(path, logger);
            }
        }
        return obj;
    }

    /// <summary>
    /// Deserialize a JSON file to an object of type T. If unsuccessful, create a new object using the supplied factory.
    /// </summary>
    /// <typeparam name="T">The type of object to deserialize</typeparam>
    /// <param name="path">The path to the JSON file to be deserialized</param>
    /// <param name="logger">An optional logger to receive log messages generated by the deserialization process</param>
    /// <param name="factory"></param>A factory method to create a new object if deserialization fails</param>
    /// <param name="rethrowDeserializationExceptions">If true, exceptions encountered during the deserialization process will be rethrown</param>
    /// <param name="renameFailedFiles">If true and the specified file cannot be successfully deserialized, it will be renamed to allow later recreation</param>
    public static async Task<T> Depersist<T>(string? path, Func<T> factory, bool rethrowDeserializationExceptions, bool renameFailedFiles, ILogger? logger, CancellationToken? cancellationToken)
    {
        T? obj = await Depersist<T>(path, rethrowDeserializationExceptions, renameFailedFiles, logger, cancellationToken);
        if (obj == null)
        {
            obj = factory();
            logger?.LogInformation("Created new object because nothing could be deserialized from {path}", path);
        }
        return obj;
    }

    /// <summary>
    /// Persist any type to a JSON file.
    /// </summary>
    /// <typeparam name="T">The type of object to be persisted.</typeparam>
    /// <param name="path">Path to the JSON file.</param>
    /// <param name="obj">Object to be persisted.</param>
    public static async Task Persist<T>(T obj, string? path, ILogger? logger, CancellationToken? cancellationToken)
    {
        if (obj is null || path is null)
        {
            return;
        }
        if (!EnsureDirectory(path))
        {
            logger?.LogError("Failed to find or create directory for {path}", path);
            return;
        }
        await using FileStream fileStream = File.Create(path);
        await JsonSerializer.SerializeAsync(fileStream, obj, s_jsonSerializerOptions, cancellationToken ?? default);
    }

    public static Persistence Persistence { get; } = new();
}
