using System.Collections.ObjectModel;
namespace Barjonas.Common.Model.Lights;

public abstract class FixturesBase<TSub> : KeyedCollection<string, Fixture>
    where TSub : FixturesBase<TSub>, new()
{
    protected Logger Logger { get; } = LogManager.GetCurrentClassLogger();
    protected static void Persist(TSub lights, IList<StatePresetGroup>? presetGroup, string? lightsPath, string? presetsPath)
    {
        Utils.Persist(lights.Select(FixtureSettings.FromFixture), lightsPath, true);
        Utils.Persist(presetGroup, presetsPath, true);
    }

    protected static TSub Depersist(string? lightsPath, string? presetsPath)
    {
        List<FixtureSettings> depersistedSettings = Depersist<List<FixtureSettings>>(lightsPath, out _);
        StatePresetGroups depersistedGroups = Depersist<StatePresetGroups>(presetsPath, out _);
        TSub newFixtures = new();
        newFixtures.Create(depersistedGroups, depersistedSettings);
        return newFixtures;
    }

    /// <summary>
    /// Update the current instance for consistency with the template generated by the subclass.
    /// </summary>
    private void Create(StatePresetGroups depersistedGroups, List<FixtureSettings> depersistedSettings)
    {
        IEnumerable<StatePresetGroup> defaultPresetGroups = BuildPresetGroups();
        _presetGroups = depersistedGroups;
        SyncPresetGroups(ref _presetGroups, defaultPresetGroups);
        _presetGroups.AddChannelTypes();
        bool startIdsAreInvalid = this.Count(f => f.StartId == 0) > 1;
        IEnumerable<Fixture> template = BuildTemplate(_presetGroups);
        Dictionary<string, FixtureSettings> settings = SettingsToDictionary(depersistedSettings);
        foreach (Fixture templateFixture in template)
        {
            if (settings.TryGetValue(templateFixture.Key, out FixtureSettings? fixtureSettings))
            {
                fixtureSettings.ToFixture(templateFixture);
            }
            Add(templateFixture);
            SetChannelParents(this[templateFixture.Key]);
        }
    }

    private Dictionary<string, FixtureSettings> SettingsToDictionary(List<FixtureSettings> depersistedSettings)
    {
        Dictionary<string, FixtureSettings> dict = new();
        foreach (FixtureSettings fs in depersistedSettings)
        {
            if (dict.ContainsKey(fs.Key))
            {
                Logger.Error("Multiple fixture settings were found with the key {0}", fs.Key);
            }
            else
            {
                dict.Add(fs.Key, fs);
            }
        }
        return dict;
    }


    private static void SetChannelParents(Fixture fixture)
    {
        foreach (FixtureChannel channel in fixture.Channels)
        {
            channel.Parent = fixture;
        }
    }

    /// <summary>
    /// Ensure that the depersisted data contains all groups which exist in the defaults
    /// </summary>
    /// <param name="depersisted"></param>
    /// <param name="defaults"></param>
    private static void SyncPresetGroups(ref StatePresetGroups depersisted, IEnumerable<StatePresetGroup> defaults)
    {
        //Note - it probably would have been smarter just copy the values from each depersisted group into its
        //corresponding default, then use the modified default instead.
        Dictionary<StatePresetGroup, StatePresetGroup> depersistedToDefault = new();
        foreach (StatePresetGroup defG in defaults)
        {
            if (depersisted.Contains(defG.Name))
            {
                //Already exists, so look deeper
                StatePresetGroup depG = depersisted[defG.Name];

                depersistedToDefault.Add(depG, defG);
                for (var i = depG.StatesLevels.Count - 1; i >= 0; i--)
                {
                    if (string.IsNullOrWhiteSpace(depG.StatesLevels[i].Key))
                    {
                        depG.StatesLevels.RemoveAt(i);
                    }
                }

                foreach (StateLevels defLevels in defG.StatesLevels)
                {
                    if (!depG.StatesLevels.Contains(defLevels.Key))
                    {
                        depG.StatesLevels.Add(defLevels);
                    }
                }

                if (depG.ChannelColors.Count != defG.ChannelColors.Count)
                {
                    depG.ChannelColors = defG.ChannelColors;
                }
            }
            else
            {
                //Doesn't exist at all, so take whole of default
                depersisted.Add(defG);
                depersistedToDefault.Add(defG, defG);
            }
        }
        List<string> groupsToRemove = new();
        foreach (StatePresetGroup depG in depersisted)
        {
            if (depersistedToDefault.ContainsKey(depG))
            {
                StatePresetGroup defG = depersistedToDefault[depG];
                List<string> levelsToRemove = depG.StatesLevels.Where(depL => !defG.StatesLevels.Contains(depL.Key)).Select(depL => depL.Key).ToList();
                foreach (string key in levelsToRemove)
                {
                    //Depersisted state levels has a key that does not exist in corresponding group in default template
                    depG.StatesLevels.Remove(key);
                }
            }
            else
            {
                groupsToRemove.Add(depG.Name);
            }
        }
        foreach (string key in groupsToRemove)
        {
            //Depersisted group has a key that does not exist in default template
            _ = depersisted.Remove(key);
        }
    }

    protected static List<FixtureChannel> ChannelsFromPreset(StatePresetGroup? presetGroup)
        => presetGroup is null ? new() : new(Enumerable.Range(0, presetGroup.ChannelColors.Count).Select(
            i =>
            new FixtureChannel(presetGroup.ChannelColors[i])
        ).ToList());

    protected abstract IEnumerable<Fixture> BuildTemplate(IEnumerable<StatePresetGroup> presetGroups);
    protected abstract IEnumerable<StatePresetGroup> BuildPresetGroups();

    private StatePresetGroups? _presetGroups;
    public StatePresetGroups? PresetGroups
    {
        get
        {
            return _presetGroups;
        }
        set
        {
            if (_presetGroups != null)
            {
                throw new InvalidOperationException($"Once {nameof(PresetGroups)} is set, it is immutable.");
            }
            _presetGroups = value;
        }
    }

    protected override string GetKeyForItem(Fixture item)
    {
        return item.Key;
    }
}
